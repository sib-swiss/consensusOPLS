---
title: 'A consensus orthogonal partial least squares discriminant analysis
(OPLS-DA) strategy for multiblock Omics data fusion.'
author: "Celine Bougel"
date: "`r format(Sys.time(), '%B %d, %Y')`"
bibliography: 20230901934_MTH2.0WP1.4_step1_1_vignette.bib
biblio-style: apalike
link-citations: yes
nocite: '@*'
output:
  html_document:
    code_folding: show
    df_print: kable
    highlight: pygments
    number_sections: yes
    self_contained: yes
    theme: journal
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: true
      smooth_scroll: true
  editor_options:
    chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

# The Consensus OPLS method

The `ConsensusOPLS` R package implements the translated `Matlab` version of the 
**Consensus OPLS(-DA)** approach [@BOCCARD2013] (available at [Gitlab repository](https://gitlab.unige.ch/Julien.Boccard/consensusopls)), with the 
kernel-based reformulations of the **NIPALS** algorithm [@LINDGREN1993]. The 
kernel reformulation of the OPLS algorithm was proposed to extend its 
applicability to non-linear relationships. The ConsensusOPLS R package includes 
updated codes from the `KOPLS` R package: codes translated from the 
`Matlab` version  were then compared and corrected, if necessary, according to 
the package source codes [@BYLESJO2008] (available at [Github repository](https://github.com/sdechaumet/ramopls/tree/master/inst/package)).

The original method was improved during translation. Among other things, 
parallelizations have been implemented, mathematical formulas have been 
generalized for application to different practical cases, and p-values have 
been added. This vignette highlights these changes as the code is executed.

<span style="color:blue"> TODO : adapter description </span> The 
current package includes some quality metrics for the optimal models, as 
**R2**, **Q2**, **DQ2** [@WESTERHUIS2008], the 
permutation **diagnostics** (Szymanska et al. 2012), the computation of the 
**VIP values** (Wold, Sjostrom, and Eriksson 2001), the score and orthogonal 
distances to detect outliers (Hubert, Rousseeuw, and Vanden Branden 2005), as 
well as many graphics (scores, loadings, predictions, diagnostics, outliers, 
etc).





# Context

Once the functions have been implemented on R, the aim was to perform a 
discriminant analysis on the `demo_data` set proposed by Julien Boccard in his 
method. This analysis concerned a selection of data from a publicly available 
repository of the National Cancer Institute, i.e. the NCI-60 data set. This data 
set provides experimental data obtained from 60 human cancer cell lines derived 
from 9 tissue origins [@SHOEMAKER2006]. Two tissue were selected in this 
study (colon versus ovary), and three data sources were chosen: transcriptomics,
proteomics and metabolomics data (3 blocks of data, evaluated on the same 
observations):

- Metabolomics: 14x 150 variables
- Microarray: 14x 200 variables
- Proteomics: 14x 100 variables

The combination of these data sources was excepted to provide a global profiling 
of the cell lines in an integrative systems biology perspective. The Consensus 
OPLS-DA strategy was applied for the differential analysis of the two selected 
tumor origins and the simultaneous analysis of the three blocks of data.





# R environment preparation

```{r setup, class.source='fold-hide'}
#install.packages("knitr")
library(knitr)
knitr::opts_chunk$set(echo = TRUE)

# To ensure repeatability
set.seed(12)
```

Before any action, it is necessary to verify that the needed packages were 
installed (the code chunks are not shown, click on `Show` to open them), and 
to define define the localisation of the codes and the files.

```{r access}
path_data_brut <- "../../../data/data_brut" 
path_data_produced <- "../../../data/data_produced/R_software" 
path_data_package <- "../../ConsensusOPLS/data" 
path_results <- "../../../results" 
```

The code below has been designed to have as few dependencies as possible on R 
packages, except for the stable packages.

```{r packages_installation, class.source='fold-hide', warning=FALSE, message=FALSE}
# install.packages(c("R.matlab", "ggplot2", "ggrepel", "stats", "utils",
#                    "parallel", "devtools", "DT", "psych"))
# update.packages(ask = FALSE)

# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("ComplexHeatmap")
```

```{r packages_load, warning=FALSE, message=FALSE, class.source='fold-hide'}
library(R.matlab) # to read MATLAB data
library(ggplot2) # to make beautiful graphs
library(ggrepel) # to annotate ggplot2 graph
library(stats) # to use R statistical functions
library(utils) # to use R utility functions
library(parallel) # to run some codes in parallel
library(devtools) # to install some packages
library(DT) # to make interactive data tables
library(psych) # to make specific quantitative summaries
library(ComplexHeatmap) # to make heatmap with density plot
```

Then we create a uniform theme that will be used for all graphic output.

```{r theme_ggplot2, class.source='fold-hide'}
theme_graphs <- theme_bw() + theme(strip.text = element_text(size=14),
                                   axis.title = element_text(size=16),
                                   axis.text = element_text(size=14),
                                   plot.title = element_text(size = 16),
                                   legend.title = element_text(size = 14))
```





# Loading functions

To execute the `ConsensusOPLS` method, tthe user must load the `ConsensusOPLS` R 
package using:

```{r load_ConsensusOPLS_package}
# Import le 04/03/2024 at 20h45
#devtools::install_github("sib-swiss/consensusOPLS/codes/ConsensusOPLS")
library(ConsensusOPLS)
```






# Data preprocessing on `Demo_data` file

As mentioned earlier, we use the demonstration dataset proposed by Julien 
Boccard:

```{r import_demo_data.mat}
demo_data <- R.matlab::readMat(con = file.path(path_data_brut, "demo_data.mat"))
```

This file corresponds to a `r class(demo_data)` of size `r length(demo_data)`.
It contains the data of `r ls(demo_data)`.

In other words, this list contains an element for the names of the data blocks. 
Each block is split into: the data table on the one hand, the variable names 
(columns) on the other. This makes two list elements for each data block. In 
addition, since the `ConsensusOPLS` method performs **horizontal integration**, 
all data blocks have the same number of samples (rows). The name of these samples 
is in a specific element of the list. Finally, the binary response matrix Y is 
in another element of this list.

## Rename Block names

In this demonstration data set, `r length(demo_data$BlockNames)` blocks of data 
were available. One for `r demo_data$BlockNames[1]` data, one for 
`r demo_data$BlockNames[2]` data, and one last for `r demo_data$BlockNames[3]` 
data. Ideally, it’s best to have the **same name for the data array and **
**variable names**, with simply a name extension for the variables (e.g. 
`VarNames` at the end of the name). In fact, to simplify code implementation 
later on, we manually rename data blocks as follows manually rename data blocks 
as follows:

```{r names_data}
demo_data$BlockNames <- c("MetaboData", "MicroData", "ProteoData")
```

## Unit variance scaling

To use the **Consensus OPLS-DA** method, it is possible to calculate the 
Z-score of the data, i.e. each columns of the data are centered to have mean 0,
and scaled to have standard deviation 1.

In the example on `Matlab`, this transformation is performed at the beginning 
of the code. In the present case, this transformation is not proposed. The user 
is free to perform it before executing the method, just after loading the data, 
and using the method of his choice.

## Collection structure

We **advise the user** to build a collection in a similar form to the one 
proposed below, so as not to encounter any errors when using the method:

```{r created_collection_data}
# Number of data blocks
nbrBlocs <- length(demo_data$BlockNames)


demo_3_Omics <- 
  lapply(X = 1:nbrBlocs, # For all data blocks
         FUN = function(X){
           ## Data sets structure
           # Extract the tables of data
           name_data <- demo_data$BlockNames[X]
           name_var <- base::gsub(pattern = "Data", replacement = "VarNames", 
                                  x = name_data, fixed = TRUE)
           
           # Extract the corresponding variables (columns) names
           colnames(demo_data[[name_data]]) <- as.character(unlist(x = demo_data[[name_var]][1, ],
                                                                   recursive = TRUE, 
                                                                   use.names = TRUE))
           data <- demo_data[[name_data]]
           
           ## Add a check on data sets
           # Extract columns length for all subjects
           col_identic_val <- base::apply(X = data, MARGIN = 2, 
                                          FUN = function(X){
                                            base::length(base::unique(X)) < 2})
           
           # Check identical values for all subjects and delete
           if(length(which(col_identic_val)) != 0){
             print(paste0("The columns ", paste(which(col_identic_val),
                                                sep = " ", 
                                                collapse = ", "), 
                          " of the ", name_data, 
                          " data contained columns with identical values."))
             data <- demo_data[[name_data]][, -which(col_identic_val)]
           } else{
             print(paste0("The ", name_data, 
                          " data doesn't contain columns with identical values."))
             data <- demo_data[[name_data]]
           }
           
           # Return the result
           return(data)
         })
```

Missing data were observed in relation to the `Matlab` data. This is due to 
columns having strictly identical values for all individuals. These columns 
were removed for the analyses. The dimensions of the data after verification 
were therefore:

```{r rename_blocks, class.source='fold-hide'}
# Rename data blocks
names(demo_3_Omics) <- demo_data$BlockNames

# Check dimension
dims <- lapply(X = 1:length(demo_3_Omics),
               FUN = function(X){dim(demo_3_Omics[[X]])})
names(dims) <- demo_data$BlockNames
dims

rm(dims)
```

So, at the end of this step, the user has a list containing `r nbrBlocs` 
(number of blocks) elements. Each element is a data array whose columns have a 
label indicating the variables under study. Columns with identical values for 
all samples (measurement errors) have been removed for the analyses.

Then, we extract the useful information for the next steps of the analyses:

```{r finishing_collection}
# Add response matrix
demo_3_Omics$Y <- demo_data$Y

# Add sample (rows) names (not useful for analysis, just for graphics)
demo_3_Omics$ObsNames <- apply(X = demo_data$ObsNames, MARGIN = 1:2,
                               FUN = unlist)
```

We then export these results for comparison with the `Matlab` version. The user 
can then load the data directly into R, without using the `R.matlab` package.

```{r export_demo_data, class.source='fold-hide'}
# In data folder
# save(demo_3_Omics, file = file.path(path_data_produced, "demo_3_Omics.RData"))

# In package folder
# save(demo_3_Omics, file = file.path(path_data_package, "demo_3_Omics.RData"))
```

All exported results were included:

```{r list_saved_results, class.source='fold-hide'}
ls(demo_3_Omics)
```

The results were observed (results not shown).

```{r view_results, class.source='fold-hide'}
# View(demo_3_Omics[[demo_data$BlockNames[1]]])
# View(demo_3_Omics[[demo_data$BlockNames[2]]])
# View(demo_3_Omics[[demo_data$BlockNames[3]]])
```

One last check: all data blocks must have the *same number of rows*, as 
indicated above. When executing the code below, either the user sees the number 
of samples (data set rows) displayed in the console, or the code stops and sends 
an error message:

```{r verif_size, class.source='fold-hide'}
size <- lapply(X = 1:length(demo_3_Omics),
               FUN = function(X){dim(demo_3_Omics[[X]])[1]})
if (all(size == size[[1]])) {
  size <- size[[1]]
  paste0("All data sets have the same number of samples: ", size, ".")
} else {
  stop("Data sets do not have the same number of samples: ", size, ".")
}
```

Here, the test is passed, we have the same number of lines.





# Data visualization

## Summary by Y groups

Before getting to the heart of the method, we offer a brief description of the 
variables, by response variable group. There are interactive tables, so the 
user can sort the variables in ascending or descending order. The user also can 
search for a variable of interest.

**Note**: variables are indicated by a final character 1 or 2 to show the group 
to which they belong in relation to variable Y.

```{r describe_data_by_Y, class.source='fold-hide'}
describe_data_by_Y <- function(data, group){
  bloc_by_Y <- psych::describeBy(x = data, group = group, 
                                 mat = TRUE)[, c("group1", "n", "mean", "sd", 
                                                 "median", "min", "max", "range", 
                                                 "se")]
  bloc_by_Y[3:ncol(bloc_by_Y)] <- round(bloc_by_Y[3:ncol(bloc_by_Y)], 
                                        digits = 2)
  return(DT::datatable(bloc_by_Y))
}

# Metabolomic
describe_data_by_Y(data = demo_3_Omics[[demo_data$BlockNames[1]]],
                   group = demo_3_Omics$Y[, 1])

#Microarray
describe_data_by_Y(data = demo_3_Omics[[demo_data$BlockNames[2]]],
                   group = demo_3_Omics$Y[, 1])

# Proteomic
describe_data_by_Y(data = demo_3_Omics[[demo_data$BlockNames[3]]],
                   group = demo_3_Omics$Y[, 1])
```


## Heatmap and density plots

```{r heatmap, message = FALSE, class.source='fold-hide'}
heatmap_data <- function(data){
  ht <- ComplexHeatmap::Heatmap(
    matrix = data, name = "Intensity",
    row_dend_width = unit(4, "cm"),
    column_dend_height = unit(4, "cm")
  )
  return(ht)
}

# For each data bloc
lapply(X = 1:nbrBlocs,
       FUN = function(X){
         bloc <- demo_data$BlockNames[X]
         print(bloc)
         heatmap_data(data = demo_3_Omics[[bloc]])})
```

```{r heatmap_density, class.source='fold-hide'}
# Heatmap with density for each data bloc
lapply(X = 1:nbrBlocs,
       FUN = function(X){
         bloc <- demo_data$BlockNames[X]
         print(bloc)
         densityHeatmap(t(demo_3_Omics[[bloc]]))})
```







# Consensus OPLS-DA model

Computation of a consensusOPLS model with leave-one-out cross-validation.

```{r define_cv_parameters}
# Number of data blocks
nbrBlocs <- length(demo_data$BlockNames)
nbrBlocs

# Number of predictive component(s)
LVsPred <- 1

# Maximum number of orthogonal components
LVsOrtho <- 1

# Number of cross-validation folds
CVfolds <- size
CVfolds
```

To use the method, you only need to call a single function. This function will 
call cross-validation. The result is the optimal model, without permutation.

```{r run_consensusOPLSmodel}
RVConsensusOPLSModelCV <- ConsensusOPLS:::RVConsensusOPLS(data = demo_3_Omics[1:nbrBlocs],
                                                          Y = demo_3_Omics$Y,
                                                          maxPcomp = LVsPred,
                                                          maxOcomp  = LVsOrtho,
                                                          nfold = CVfolds,
                                                          cvType = "nfold",
                                                          modelType = "da",
                                                          mc.cores = 1,
                                                          verbose = FALSE)
```





# Display the main results

As indicated at the beginning of the thumbnail, the R package `ConsensusOPLS` 
calculates:

- the R² coefficient

```{r print_main_results_R2, class.source='fold-hide'}
position <- RVConsensusOPLSModelCV$cv$OrthoLVsOptimalNum+1

paste0('R2: ', round(RVConsensusOPLSModelCV$Model$R2Yhat[position], 4))
```

- the Q² value is defined as `1 - (PRESS/ TSS)`, with `PRESS` is the prediction 
error sum of squares, and `TSS` is the total sum of squares of the response 
vector Y. This value is a measure for class prediction ability [@WESTERHUIS2008].

```{r print_main_results_Q2, class.source='fold-hide'}
paste0('Q2: ', round(RVConsensusOPLSModelCV$cv$Q2Yhat[position], 4))
```

- the discriminant Q² index (`DQ2`) to assess the model fit as it does not 
penalize class predictions beyond the class label value. The `DQ2` is defined 
as `1 - (PRESSD/ TSS)`, with PRESSD is the prediction error sum of squares, 
disregarded when the class prediction is beyond the class label, and `TSS` is the 
total sum of squares of the response vector Y. This value is a measure for class 
prediction ability [@WESTERHUIS2008].

```{r print_main_results_DQ2, class.source='fold-hide'}
paste0('DQ2: ', round(RVConsensusOPLSModelCV$cv$DQ2Yhat[position], 4))
```

```{r print_main_results_Confusion_matrix, class.source='fold-hide'}
RVConsensusOPLSModelCV$da$confusMatrix
```


```{r print_VIP, class.source='fold-hide'}
VIP <- ConsensusOPLS:::MBVIP(data = demo_3_Omics[1:nbrBlocs], 
                             Y = demo_3_Omics$Y, 
                             model = RVConsensusOPLSModelCV,
                             mc.cores = 1)
names(VIP) <- demo_data$BlockNames
```



# Plot the results

## Consensus Score plot

```{r ggplot_score_data, class.source='fold-hide', warning=FALSE}
ggplot2::ggplot(data = data.frame("p_1" = RVConsensusOPLSModelCV$Model$scoresP,
                                  "o_1" = RVConsensusOPLSModelCV$Model$scoresO,
                                  "Labs" = as.matrix(base::unlist(demo_data$ObsNames[, 1]))),
                aes(x = p_1, y = o_1, label = Labs, 
                    shape = Labs, colour = Labs)) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("ConsensusOPLS Score plot")+
  ggplot2::geom_point(size = 2.5) + 
  ggrepel::geom_text_repel(size = 4, show.legend = FALSE) + 
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```

## Block contributions to the predictive component

```{r ggplot_data_pred_compo, class.source='fold-hide'}
ggplot2::ggplot(data = data.frame("Values" = RVConsensusOPLSModelCV$Model$lambda[,1],
                                  "Blocks" = as.factor(labels(demo_3_Omics[1:nbrBlocs]))),
                aes(x = Blocks, y = Values,
                    fill = Blocks, labels = Values)) +
  ggplot2::geom_bar(stat = 'identity') + 
  ggplot2::xlab("Data blocks") +
  ggplot2::ylab("Weight") +
  ggplot2::ggtitle("Block contributions to the predictive component")+
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#1B9E77", "#D95F02", "#7570B3"))
```

## Block contributions to the first orthogonal component

```{r ggplot_data_1st_ortho_compo, class.source='fold-hide'}
ggplot2::ggplot(data = data.frame("Values" = RVConsensusOPLSModelCV$Model$lambda[,2],
                                  "Blocks" = as.factor(labels(demo_3_Omics[1:nbrBlocs]))),
                aes(x = Blocks, y = Values,
                    fill = Blocks, labels = Values)) +
  ggplot2::geom_bar(stat = 'identity') + 
  ggplot2::xlab("Data blocks") +
  ggplot2::ylab("Weight") +
  ggplot2::ggtitle("Block contributions to the first orthogonal component")+
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#1B9E77", "#D95F02", "#7570B3"))
```

## Block contributions: the two previous plots into one

```{r ggplot_data_pred_ortho, message = FALSE, class.source='fold-hide'}
data_two_plots <- data.frame("Values" = RVConsensusOPLSModelCV$Model$lambda[,1],
                             "Type" = "Pred",
                             "Blocks" = labels(demo_3_Omics[1:nbrBlocs]))
data_two_plots <- data.frame("Values" = c(data_two_plots$Values,
                                          RVConsensusOPLSModelCV$Model$lambda[,2]),
                             "Type" = c(data_two_plots$Type,
                                        rep("1st_ortho", times = length(RVConsensusOPLSModelCV$Model$lambda[,2]))),
                             "Blocks" = c(data_two_plots$Blocks,
                                          labels(demo_3_Omics[1:nbrBlocs])))

ggplot2::ggplot(data = data_two_plots,
                aes(x = factor(Type), y = Values, fill = factor(Type))) +
  ggplot2::geom_bar(stat = 'identity') + 
  ggplot2::xlab("Data blocks") +
  ggplot2::ylab("Weight") +
  ggplot2::ggtitle("Block contributions to each component")+
  facet_wrap(. ~ Blocks)+
  theme_graphs+
  ggplot2::scale_fill_discrete(name = "Component")+
  ggplot2::scale_fill_manual(values = c("#7F3C8D", "#11A579"))
```



## Block contributions predictive vs. orthogonal

```{r ggplot_data_pred_vs_ortho, class.source='fold-hide'}
ggplot2::ggplot(data = data.frame("Pred" = RVConsensusOPLSModelCV$Model$lambda[,1],
                                  "Ortho" = RVConsensusOPLSModelCV$Model$lambda[,2],
                                  "Labels" = labels(demo_3_Omics[1:nbrBlocs])),
                aes(x = Pred, y = Ortho, label = Labels, 
                    shape = Labels, colour = Labels)) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("Block contributions predictive vs. orthogonal")+
  ggplot2::geom_point(size = 2.5) + 
  ggrepel::geom_text_repel(size = 4, show.legend = FALSE) + 
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#1B9E77", "#D95F02", "#7570B3"))
```

## Loading plots (one for each table)

```{r create_data_loadings}
loadings <- RVConsensusOPLSModelCV$Model$loadings
data_loads <- sapply(X = 1:nbrBlocs,
                     FUN = function(X){
                       data.frame("Pred" = 
                                    loadings[[X]][, base::grep(pattern = "p_",
                                                               x = colnames(loadings[[X]]),
                                                               fixed = TRUE)],
                                  "Ortho" = 
                                    loadings[[X]][, base::grep(pattern = "o_",
                                                               x = colnames(loadings[[X]]),
                                                               fixed = TRUE)],
                                  "Labels" = labels(demo_3_Omics[1:nbrBlocs])[[X]])
                     })
data_loads <- as.data.frame(data_loads)
```

```{r ggplot_data_loadings, class.source='fold-hide'}
ggplot2::ggplot(data = data_loads) +
  ggplot2::geom_point(data = as.data.frame(data_loads$V1),
                      aes(x = Pred, y = Ortho, colour = Labels), 
                      size = 2.5, alpha = 0.5) + 
  ggplot2::geom_point(data = as.data.frame(data_loads$V2),
                      aes(x = Pred, y = Ortho, colour = Labels),
                      size = 2.5, alpha = 0.5) +
  ggplot2::geom_point(data = as.data.frame(data_loads$V3),
                      aes(x = Pred, y = Ortho, colour = Labels),
                      size = 2.5, alpha = 0.5) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("ConsensusOPLS Loading plot")+
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#1B9E77", "#D95F02", "#7570B3"))
```





# Permutations

```{r run_permutations, warning=FALSE}
PermRes <- ConsensusOPLS:::RVConsensusOPLSPerm(data = demo_3_Omics[1:nbrBlocs],
                                               Y = demo_3_Omics$Y,
                                               maxPcomp = LVsPred,
                                               maxOcomp  = LVsOrtho,
                                               nfold = CVfolds,
                                               nperm = 1000,
                                               cvType = "nfold",
                                               modelType = "da",
                                               mc.cores = 1,
                                               verbose = FALSE)
```

```{r plot1_perm}
PermRes$plots$R2val
```

```{r plot2_perm}
PermRes$plots$Q2val
```

```{r plot3_perm}
PermRes$plots$R2_and_Q2
```

```{r plot4_perm}
PermRes$plots$R2val_hist
```

```{r plot5_perm}
PermRes$plots$Q2val_hist
```

```{r plot6_perm}
PermRes$plots$R2_and_Q2_hist
```















# Reproducibility

Here is the output of `sessionInfo()` on the system on which this document was 
compiled:

```{r reproducibility}
sessionInfo()
```

# References
